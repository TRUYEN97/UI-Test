<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AutoMapper</name>
    </assembly>
    <members>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution. When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ParamCollectionAttribute">
            <summary>
            Indicates that a method will allow a variable number of arguments in its invocation.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>
            Specifies that null is allowed as an input even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute">
            <summary>
            Indicates that the specified method parameter expects a constant.
            </summary>
            <remarks>
            This can be used to inform tooling that a constant should be used as an argument for the annotated parameter.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Min">
            <summary>
            Indicates the minimum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Max">
            <summary>
            Indicates the maximum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>
            Specifies that null is disallowed as an input even if the corresponding type allows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
            Applied to a method that will never return under any circumstance.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
            Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable
            by diagnostics if the argument to the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets the condition parameter value.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>
            Specifies that an output may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter may be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with a field or property member.
            </summary>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property
            members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>
            Specifies that an output will not be null even if the corresponding type allows it.
            Specifies that an input argument was not null when the call returns.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>
            Specifies that the output will be non-null if the named parameter is non-null.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with the associated parameter name.
            </summary>
            <param name="parameterName">The associated parameter name. The output will be non-null if the argument to the parameter specified is non-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>
            Gets the associated parameter name.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:AutoMapper.AutoMapperMappingException">
            <summary>
            Wraps mapping exceptions. Check exception.ToString() for the full error message.
            </summary>
        </member>
        <member name="T:AutoMapper.AutoMapAttribute">
            <summary>
            Auto map to this destination type from the specified source type.
            Discovered during scanning assembly scanning for configuration when calling <see cref="O:AutoMapper.IMapperConfigurationExpression.AddMaps"/>
            </summary>
        </member>
        <member name="M:AutoMapper.AutoMapAttribute.#ctor(System.Type)">
            <summary>
            Auto map to this destination type from the specified source type.
            Discovered during scanning assembly scanning for configuration when calling <see cref="O:AutoMapper.IMapperConfigurationExpression.AddMaps"/>
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.ConstructUsingServiceLocator">
            <summary>
            If set to true, construct the destination object using the service locator.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.MaxDepth">
            <summary>
            For self-referential types, limit recurse depth.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.PreserveReferences">
            <summary>
            If set to true, preserve object identity. Useful for circular references.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.DisableCtorValidation">
            <summary>
            If set to true, disable constructor validation.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.IncludeAllDerived">
            <summary>
            If set to true, include this configuration in all derived types' maps.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.TypeConverter">
            <summary>
            Skip normal member mapping and convert using a <see cref="T:AutoMapper.ITypeConverter`2"/> instantiated during mapping.
            </summary>
        </member>
        <member name="P:AutoMapper.AutoMapAttribute.AsProxy">
            <summary>
            If set to true, proxy will be created.
            </summary>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.IgnoreAttribute">
            <summary>
            Ignore this member for configuration validation and skip during mapping.
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.MapAtRuntimeAttribute">
            <summary>
            Do not precompute the execution plan for this member, just map it at runtime.
            Simplifies the execution plan by not inlining.
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.MappingOrderAttribute">
            <summary>
            Supply a custom mapping order instead of what the .NET runtime returns
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="M:AutoMapper.Configuration.Annotations.MappingOrderAttribute.#ctor(System.Int32)">
            <summary>
            Supply a custom mapping order instead of what the .NET runtime returns
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.NullSubstituteAttribute">
            <summary>
            Substitute a custom value when the source member resolves as null
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="M:AutoMapper.Configuration.Annotations.NullSubstituteAttribute.#ctor(System.Object)">
            <summary>
            Substitute a custom value when the source member resolves as null
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="P:AutoMapper.Configuration.Annotations.NullSubstituteAttribute.Value">
            <summary>
            Value to use if source value is null
            </summary>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.SourceMemberAttribute">
            <summary>
            Specify the source member to map from. Can only reference a member on the <see cref="P:AutoMapper.AutoMapAttribute.SourceType" /> type
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="M:AutoMapper.Configuration.Annotations.SourceMemberAttribute.#ctor(System.String)">
            <summary>
            Specify the source member to map from. Can only reference a member on the <see cref="P:AutoMapper.AutoMapAttribute.SourceType" /> type
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.UseExistingValueAttribute">
            <summary>
            Use the destination value instead of mapping from the source value or creating a new instance
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.ValueConverterAttribute">
            <summary>
            Specify a value converter type to convert from the matching source member to the destination member
            Use with <see cref="T:AutoMapper.Configuration.Annotations.SourceMemberAttribute" /> to specify a separate source member to supply to the value converter
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="M:AutoMapper.Configuration.Annotations.ValueConverterAttribute.#ctor(System.Type)">
            <summary>
            Specify a value converter type to convert from the matching source member to the destination member
            Use with <see cref="T:AutoMapper.Configuration.Annotations.SourceMemberAttribute" /> to specify a separate source member to supply to the value converter
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="P:AutoMapper.Configuration.Annotations.ValueConverterAttribute.Type">
            <summary>
            <see cref="T:AutoMapper.IValueConverter`2" /> type
            </summary>
        </member>
        <member name="T:AutoMapper.Configuration.Annotations.ValueResolverAttribute">
            <summary>
            Map destination member using a custom value resolver.
            Use with <see cref="T:AutoMapper.Configuration.Annotations.SourceMemberAttribute" /> to specify an <see cref="T:AutoMapper.IMemberValueResolver`4" /> type.
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="M:AutoMapper.Configuration.Annotations.ValueResolverAttribute.#ctor(System.Type)">
            <summary>
            Map destination member using a custom value resolver.
            Use with <see cref="T:AutoMapper.Configuration.Annotations.SourceMemberAttribute" /> to specify an <see cref="T:AutoMapper.IMemberValueResolver`4" /> type.
            </summary>
            <remarks>
            Must be used in combination with <see cref="T:AutoMapper.AutoMapAttribute" />
            </remarks>
        </member>
        <member name="P:AutoMapper.Configuration.Annotations.ValueResolverAttribute.Type">
            <summary>
            <see cref="T:AutoMapper.IValueResolver`3" /> or <see cref="T:AutoMapper.IMemberValueResolver`4" /> type
            </summary>
        </member>
        <member name="M:AutoMapper.Configuration.ICtorParamConfigurationExpression.MapFrom(System.String)">
            <summary>
            Specify the source member(s) to map from.
            </summary>
            <param name="sourceMembersPath">Property name referencing the source member to map against. Or a dot separated member path.</param>
        </member>
        <member name="M:AutoMapper.Configuration.ICtorParamConfigurationExpression.ExplicitExpansion(System.Boolean)">
            <summary>
            Ignore this member for LINQ projections unless explicitly expanded during projection
            </summary>
            <param name="value">Is explicitExpansion active</param>
        </member>
        <member name="M:AutoMapper.Configuration.ICtorParamConfigurationExpression`1.MapFrom``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Map constructor parameter from member expression
            </summary>
            <typeparam name="TMember">Member type</typeparam>
            <param name="sourceMember">Member expression</param>
        </member>
        <member name="M:AutoMapper.Configuration.ICtorParamConfigurationExpression`1.MapFrom``1(System.Func{`0,AutoMapper.ResolutionContext,``0})">
            <summary>
            Map constructor parameter from custom func that has access to <see cref="T:AutoMapper.ResolutionContext"/>
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="resolver">Custom func</param>
        </member>
        <member name="T:AutoMapper.Configuration.IPathConfigurationExpression`3">
            <summary>
            Member configuration options
            </summary>
            <typeparam name="TSource">Source type for this member</typeparam>
            <typeparam name="TDestination">Destination type for this map</typeparam>
            <typeparam name="TMember">Type for this member</typeparam>
        </member>
        <member name="M:AutoMapper.Configuration.IPathConfigurationExpression`3.MapFrom``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Specify the source member to map from. Can only reference a member on the <typeparamref name="TSource"/> type
            Any null reference exceptions in this expression will be ignored (similar to flattening behavior)
            </summary>
            <typeparam name="TSourceMember">Member type of the source member to use</typeparam>
            <param name="sourceMember">Expression referencing the source member to map against</param>
        </member>
        <member name="M:AutoMapper.Configuration.IPathConfigurationExpression`3.Ignore">
            <summary>
            Ignore this member for configuration validation and skip during mapping
            </summary>
        </member>
        <member name="T:AutoMapper.Configuration.ISourceMemberConfigurationExpression">
            <summary>
            Source member configuration options
            </summary>
        </member>
        <member name="M:AutoMapper.Configuration.ISourceMemberConfigurationExpression.DoNotValidate">
            <summary>
            Ignore this member when validating source members, MemberList.Source.
            Does not affect validation for the default case, MemberList.Destination.
            </summary>
        </member>
        <member name="T:AutoMapper.Configuration.SourceMemberConfig">
            <summary>
            Contains member configuration relating to source members
            </summary>
        </member>
        <member name="M:AutoMapper.Configuration.SourceMemberConfig.#ctor(System.Reflection.MemberInfo)">
            <summary>
            Contains member configuration relating to source members
            </summary>
        </member>
        <member name="T:AutoMapper.IMappingExpression">
            <summary>
            Mapping configuration options for non-generic maps
            </summary>
        </member>
        <member name="M:AutoMapper.IMappingExpression.IncludeMembers(System.String[])">
            <summary>
            Add extra configuration to the current map by also mapping the specified child objects to the destination object.
            The maps from the child types to the destination need to be created explicitly.
            </summary>
            <param name="memberNames">the names of child object properties to map to the destination</param>
            <returns></returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression.ReverseMap">
            <summary>
            Create a type mapping from the destination to the source type, with validation disabled.
            This allows for two-way mapping.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression.ForAllMembers(System.Action{AutoMapper.IMemberConfigurationExpression})">
            <summary>
            Customize configuration for all members
            </summary>
            <param name="memberOptions">Callback for member options</param>
        </member>
        <member name="M:AutoMapper.IMappingExpression.ForMember(System.String,System.Action{AutoMapper.IMemberConfigurationExpression})">
            <summary>
            Customize individual members
            </summary>
            <param name="name">Name of the member</param>
            <param name="memberOptions">Callback for configuring member</param>
            <returns>Itself</returns>
        </member>
        <member name="T:AutoMapper.IMappingExpression`2">
            <summary>
            Mapping configuration options
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ForPath``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{AutoMapper.Configuration.IPathConfigurationExpression{`0,`1,``0}})">
            <summary>
            Customize configuration for a path inside the destination object.
            </summary>
            <param name="destinationMember">Expression to the destination sub object</param>
            <param name="memberOptions">Callback for member options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ForMember``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{AutoMapper.IMemberConfigurationExpression{`0,`1,``0}})">
            <summary>
            Customize configuration for individual member
            </summary>
            <param name="destinationMember">Expression to the top-level destination member. This must be a member on the <typeparamref name="TDestination"/>TDestination</param> type
            <param name="memberOptions">Callback for member options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ForMember(System.String,System.Action{AutoMapper.IMemberConfigurationExpression{`0,`1,System.Object}})">
            <summary>
            Customize configuration for individual member. Used when the name isn't known at compile-time
            </summary>
            <param name="name">Destination member name</param>
            <param name="memberOptions">Callback for member options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ForAllMembers(System.Action{AutoMapper.IMemberConfigurationExpression{`0,`1,System.Object}})">
            <summary>
            Customize configuration for all members
            </summary>
            <param name="memberOptions">Callback for member options</param>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.Include``2">
            <summary>
            Include this configuration in derived types' maps
            </summary>
            <typeparam name="TOtherSource">Derived source type</typeparam>
            <typeparam name="TOtherDestination">Derived destination type</typeparam>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.IncludeBase``2">
            <summary>
            Include the base type map's configuration in this map
            </summary>
            <typeparam name="TSourceBase">Base source type</typeparam>
            <typeparam name="TDestinationBase">Base destination type</typeparam>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ForSourceMember(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{AutoMapper.Configuration.ISourceMemberConfigurationExpression})">
            <summary>
            Customize configuration for an individual source member
            </summary>
            <param name="sourceMember">Expression to source member. Must be a member of the <typeparamref name="TSource"/> type</param>
            <param name="memberOptions">Callback for member configuration options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.ReverseMap">
            <summary>
            Create a type mapping from the destination to the source type, with validation disabled.
            This allows for two-way mapping.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpression`2.As``1">
            <summary>
            Override the destination type mapping for looking up configuration and instantiation
            </summary>
            <typeparam name="T">Destination type to use</typeparam>
        </member>
        <member name="M:AutoMapper.IProjectionExpression`3.AddTransform``1(System.Linq.Expressions.Expression{System.Func{``0,``0}})">
            <summary>
            Apply a transformation function after any resolved destination member value with the given type
            </summary>
            <typeparam name="TValue">Value type to match and transform</typeparam>
            <param name="transformer">Transformation expression</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IProjectionExpression`3.IncludeMembers(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Add extra configuration to the current map by also mapping the specified child objects to the destination object.
            The maps from the child types to the destination need to be created explicitly.
            </summary>
            <param name="memberExpressions">the child objects to map to the destination</param>
            <returns></returns>
        </member>
        <member name="M:AutoMapper.IProjectionExpression`2.ForMember``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{AutoMapper.IProjectionMemberConfiguration{`0,`1,``0}})">
            <summary>
            Customize configuration for individual member
            </summary>
            <param name="destinationMember">Expression to the top-level destination member. This must be a member on the <typeparamref name="TDestination"/>TDestination</param> type
            <param name="memberOptions">Callback for member options</param>
            <returns>Itself</returns>
        </member>
        <member name="T:AutoMapper.IProjectionExpressionBase`3">
            <summary>
            Common mapping configuration options between generic and non-generic mapping configuration
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <typeparam name="TMappingExpression">Concrete return type for fluent interface</typeparam>
        </member>
        <member name="M:AutoMapper.IProjectionExpressionBase`3.MaxDepth(System.Int32)">
            <summary>
            For self-referential types, limit recurse depth.
            Enables PreserveReferences.
            </summary>
            <param name="depth">Number of levels to limit to</param>
            <returns>Itself</returns>
        </member>
        <member name="P:AutoMapper.IProjectionExpressionBase`3.ValueTransformers">
            <summary>
            Value transformers, typically configured through explicit or extension methods.
            </summary>
        </member>
        <member name="M:AutoMapper.IProjectionExpressionBase`3.ValidateMemberList(AutoMapper.MemberList)">
            <summary>
            Specify which member list to validate
            </summary>
            <param name="memberList">Member list to validate</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IProjectionExpressionBase`3.ConstructUsing(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Supply a custom instantiation expression for the destination type
            </summary>
            <param name="ctor">Expression to create the destination type given the source object</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IProjectionExpressionBase`3.ForCtorParam(System.String,System.Action{AutoMapper.Configuration.ICtorParamConfigurationExpression{`0}})">
            <summary>
            Customize configuration for individual constructor parameter
            </summary>
            <param name="ctorParamName">Constructor parameter name</param>
            <param name="paramOptions">Options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IProjectionExpressionBase`3.ConvertUsing(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Skip member mapping and use a custom expression to convert to the destination type
            </summary>
            <param name="mappingExpression">Callback to convert from source type to destination type</param>
        </member>
        <member name="T:AutoMapper.IMappingExpressionBase`3">
            <summary>
            Common mapping configuration options between generic and non-generic mapping configuration
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <typeparam name="TMappingExpression">Concrete return type for fluent interface</typeparam>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.DisableCtorValidation">
            <summary>
            Disable constructor validation. During mapping this map is used against an existing destination object and never constructed itself.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConstructUsingServiceLocator">
            <summary>
            Construct the destination object using the service locator
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.PreserveReferences">
            <summary>
            Preserve object identity. Useful for circular references.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.BeforeMap(System.Action{`0,`1})">
            <summary>
            Execute a custom function to the source and/or destination types before member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="beforeFunction">Callback for the source/destination types</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.BeforeMap(System.Action{`0,`1,AutoMapper.ResolutionContext})">
            <summary>
            Execute a custom function to the source and/or destination types before member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="beforeFunction">Callback for the source/destination types</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.BeforeMap``1">
            <summary>
            Execute a custom mapping action before member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TMappingAction">Mapping action type instantiated during mapping</typeparam>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.AfterMap(System.Action{`0,`1})">
            <summary>
            Execute a custom function to the source and/or destination types after member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="afterFunction">Callback for the source/destination types</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.AfterMap(System.Action{`0,`1,AutoMapper.ResolutionContext})">
            <summary>
            Execute a custom function to the source and/or destination types after member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="afterFunction">Callback for the source/destination types</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.AfterMap``1">
            <summary>
            Execute a custom mapping action after member mapping
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TMappingAction">Mapping action type instantiated during mapping</typeparam>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.IncludeAllDerived">
            <summary>
            Include this configuration in all derived types' maps. Works by scanning all type maps for matches during configuration.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.Include(System.Type,System.Type)">
            <summary>
            Include this configuration in derived types' maps
            </summary>
            <param name="derivedSourceType">Derived source type</param>
            <param name="derivedDestinationType">Derived destination type</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.IncludeBase(System.Type,System.Type)">
            <summary>
            Include the base type map's configuration in this map
            </summary>
            <param name="sourceBase">Base source type</param>
            <param name="destinationBase">Base destination type</param>
            <returns></returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ForSourceMember(System.String,System.Action{AutoMapper.Configuration.ISourceMemberConfigurationExpression})">
            <summary>
            Customize configuration for an individual source member. Member name not known until runtime
            </summary>
            <param name="sourceMemberName">Expression to source member. Must be a member of the <typeparamref name="TSource"/> type</param>
            <param name="memberOptions">Callback for member configuration options</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.IgnoreAllPropertiesWithAnInaccessibleSetter">
            <summary>
            Ignores all <typeparamref name="TDestination"/> properties that have either a private or protected setter, forcing the mapper to respect encapsulation (note: order matters, so place this before explicit configuration of any properties with an inaccessible setter)
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.IgnoreAllSourcePropertiesWithAnInaccessibleSetter">
            <summary>
            When using ReverseMap, ignores all <typeparamref name="TSource"/> properties that have either a private or protected setter, keeping the reverse mapping consistent with the forward mapping (note: <typeparamref name="TDestination"/> properties with an inaccessible setter may still be mapped unless IgnoreAllPropertiesWithAnInaccessibleSetter is also used)
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConstructUsing(System.Func{`0,AutoMapper.ResolutionContext,`1})">
            <summary>
            Supply a custom instantiation function for the destination type, based on the entire resolution context
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="ctor">Callback to create the destination type given the current resolution context</param>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.As(System.Type)">
            <summary>
            Override the destination type mapping for looking up configuration and instantiation
            </summary>
            <param name="typeOverride"></param>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.AsProxy">
            <summary>
            Create at runtime a proxy type implementing the destination interface.
            </summary>
            <returns>Itself</returns>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConvertUsing(System.Type)">
            <summary>
            Skip normal member mapping and convert using a <see cref="T:AutoMapper.ITypeConverter`2"/> instantiated during mapping
            Use this method if you need to specify the converter type at runtime
            </summary>
            <param name="typeConverterType">Type converter type</param>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConvertUsing(System.Func{`0,`1,`1})">
            <summary>
            Skip member mapping and use a custom function to convert to the destination type
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="mappingFunction">Callback to convert from source type to destination type, including destination object</param>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConvertUsing(System.Func{`0,`1,AutoMapper.ResolutionContext,`1})">
            <summary>
            Skip member mapping and use a custom function to convert to the destination type
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="mappingFunction">Callback to convert from source type to destination type, with source, destination and context</param>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConvertUsing(AutoMapper.ITypeConverter{`0,`1})">
            <summary>
            Skip member mapping and use a custom type converter instance to convert to the destination type
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="converter">Type converter instance</param>
        </member>
        <member name="M:AutoMapper.IMappingExpressionBase`3.ConvertUsing``1">
            <summary>
            Skip member mapping and use a custom type converter instance to convert to the destination type
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TTypeConverter">Type converter type</typeparam>
        </member>
        <member name="T:AutoMapper.IMappingAction`2">
            <summary>
            Custom mapping action
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
        </member>
        <member name="M:AutoMapper.IMappingAction`2.Process(`0,`1,AutoMapper.ResolutionContext)">
            <summary>
            Implementors can modify both the source and destination objects
            </summary>
            <param name="source">Source object</param>
            <param name="destination">Destination object</param>
            <param name="context">Resolution context</param>
        </member>
        <member name="T:AutoMapper.ITypeConverter`2">
            <summary>
            Converts source type to destination type instead of normal member mapping
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
        </member>
        <member name="M:AutoMapper.ITypeConverter`2.Convert(`0,`1,AutoMapper.ResolutionContext)">
            <summary>
            Performs conversion from source to destination type
            </summary>
            <param name="source">Source object</param>
            <param name="destination">Destination object</param>
            <param name="context">Resolution context</param>
            <returns>Destination object</returns>
        </member>
        <member name="T:AutoMapper.IMappingOperationOptions">
            <summary>
            Options for a single map operation
            </summary>
        </member>
        <member name="M:AutoMapper.IMappingOperationOptions.ConstructServicesUsing(System.Func{System.Type,System.Object})">
            <summary>
            Construct services using this callback. Use this for child/nested containers
            </summary>
            <param name="constructor"></param>
        </member>
        <member name="P:AutoMapper.IMappingOperationOptions.State">
            <summary>
            Add state to be accessed at map time inside an <see cref="T:AutoMapper.IValueResolver`3"/> or <see cref="T:AutoMapper.ITypeConverter`2"/>.
            Mutually exclusive with <see cref="P:AutoMapper.IMappingOperationOptions.Items"/> per Map call.
            </summary>
        </member>
        <member name="P:AutoMapper.IMappingOperationOptions.Items">
            <summary>
            Add context items to be accessed at map time inside an <see cref="T:AutoMapper.IValueResolver`3"/> or <see cref="T:AutoMapper.ITypeConverter`2"/>.
            Mutually exclusive with <see cref="P:AutoMapper.IMappingOperationOptions.State"/> per Map call.
            </summary>
        </member>
        <member name="M:AutoMapper.IMappingOperationOptions.BeforeMap(System.Action{System.Object,System.Object})">
            <summary>
            Execute a custom function to the source and/or destination types before member mapping
            </summary>
            <param name="beforeFunction">Callback for the source/destination types</param>
        </member>
        <member name="M:AutoMapper.IMappingOperationOptions.AfterMap(System.Action{System.Object,System.Object})">
            <summary>
            Execute a custom function to the source and/or destination types after member mapping
            </summary>
            <param name="afterFunction">Callback for the source/destination types</param>
        </member>
        <member name="M:AutoMapper.IMappingOperationOptions`2.BeforeMap(System.Action{`0,`1})">
            <summary>
            Execute a custom function to the source and/or destination types before member mapping
            </summary>
            <param name="beforeFunction">Callback for the source/destination types</param>
        </member>
        <member name="M:AutoMapper.IMappingOperationOptions`2.AfterMap(System.Action{`0,`1})">
            <summary>
            Execute a custom function to the source and/or destination types after member mapping
            </summary>
            <param name="afterFunction">Callback for the source/destination types</param>
        </member>
        <member name="T:AutoMapper.IMemberConfigurationExpression`3">
            <summary>
            Member configuration options
            </summary>
            <typeparam name="TSource">Source type for this member</typeparam>
            <typeparam name="TMember">Type for this member</typeparam>
            <typeparam name="TDestination">Destination type for this map</typeparam>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapAtRuntime">
            <summary>
            Do not precompute the execution plan for this member, just map it at runtime.
            Simplifies the execution plan by not inlining.
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``1">
            <summary>
            Map destination member using a custom value resolver
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TValueResolver">Value resolver type</typeparam>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
            <summary>
            Map destination member using a custom member value resolver supplied with a source member
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TValueResolver">Value resolver type</typeparam>
            <typeparam name="TSourceMember">Source member to supply</typeparam>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``2(System.String)">
            <summary>
            Map destination member using a custom member value resolver supplied from a source member name
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <typeparam name="TValueResolver">Value resolver type</typeparam>
            <typeparam name="TSourceMember">Source member to supply</typeparam>
            <param name="sourceMemberName">Source member name</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom(AutoMapper.IValueResolver{`0,`1,`2})">
            <summary>
            Map destination member using a custom value resolver instance
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="valueResolver">Value resolver instance to use</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``1(AutoMapper.IMemberValueResolver{`0,`1,``0,`2},System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Map destination member using a custom value resolver instance
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="valueResolver">Value resolver instance to use</param>
            <param name="sourceMember">Source member to supply to value resolver</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``1(System.Func{`0,`1,``0})">
            <summary>
            Map destination member using a custom function. Access both the source and destination object.
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="mappingFunction">Function to map to destination member</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``1(System.Func{`0,`1,`2,``0})">
            <summary>
            Map destination member using a custom function. Access the source, destination object, and destination member.
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="mappingFunction">Function to map to destination member</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom``1(System.Func{`0,`1,`2,AutoMapper.ResolutionContext,``0})">
            <summary>
            Map destination member using a custom function. Access the source, destination object, destination member, and context.
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="mappingFunction">Function to map to destination member</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.MapFrom(System.String)">
            <summary>
            Specify the source member(s) to map from.
            </summary>
            <param name="sourceMembersPath">Property name referencing the source member to map against. Or a dot separated member path.</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.SetMappingOrder(System.Int32)">
            <summary>
            Supply a custom mapping order instead of what the .NET runtime returns
            </summary>
            <param name="mappingOrder">Mapping order value</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.DoNotUseDestinationValue">
            <summary>
            Reset UseDestinationValue.
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.UseDestinationValue">
            <summary>
            Use the destination value instead of mapping from the source value or creating a new instance
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.Condition(System.Func{`0,`1,`2,`2,AutoMapper.ResolutionContext,System.Boolean})">
            <summary>
            Conditionally map this member against the source, destination, source and destination members
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.Condition(System.Func{`0,`1,`2,`2,System.Boolean})">
            <summary>
            Conditionally map this member
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.Condition(System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Conditionally map this member
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.Condition(System.Func{`0,`1,System.Boolean})">
            <summary>
            Conditionally map this member
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.Condition(System.Func{`0,System.Boolean})">
            <summary>
            Conditionally map this member
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.PreCondition(System.Func{`0,System.Boolean})">
            <summary>
            Conditionally map this member, evaluated before accessing the source value
            </summary>
            <param name="condition">Condition to evaluate using the source object</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.PreCondition(System.Func{AutoMapper.ResolutionContext,System.Boolean})">
            <summary>
            Conditionally map this member, evaluated before accessing the source value
            </summary>
            <param name="condition">Condition to evaluate using the current resolution context</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.PreCondition(System.Func{`0,AutoMapper.ResolutionContext,System.Boolean})">
            <summary>
            Conditionally map this member, evaluated before accessing the source value
            </summary>
            <param name="condition">Condition to evaluate using the source object and the current resolution context</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.PreCondition(System.Func{`0,`1,AutoMapper.ResolutionContext,System.Boolean})">
            <summary>
            Conditionally map this member, evaluated before accessing the source value
            </summary>
            <param name="condition">Condition to evaluate using the source object, the destination object, and the current resolution context</param>
        </member>
        <member name="P:AutoMapper.IMemberConfigurationExpression`3.DestinationMember">
            <summary>
            The destination member being configured.
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``2">
            <summary>
            Specify a value converter to convert from the matching source member to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TValueConverter">Value converter type</typeparam>
            <typeparam name="TSourceMember">Source member type</typeparam>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
            <summary>
            Specify a value converter to convert from the specified source member to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TValueConverter">Value converter type</typeparam>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <param name="sourceMember">Source member to supply to the value converter</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``2(System.String)">
            <summary>
            Specify a value converter to convert from the specified source member name to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TValueConverter">Value converter type</typeparam>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <param name="sourceMemberName">Source member name to supply to the value converter</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``1(AutoMapper.IValueConverter{``0,`2})">
            <summary>
            Specify a value converter instance to convert from the matching source member to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <param name="valueConverter">Value converter instance</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``1(AutoMapper.IValueConverter{``0,`2},System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Specify a value converter instance from the specified source member to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <param name="valueConverter">Value converter instance</param>
            <param name="sourceMember">Source member to supply to the value converter</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression`3.ConvertUsing``1(AutoMapper.IValueConverter{``0,`2},System.String)">
            <summary>
            Specify a value converter instance to convert from the specified source member name to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <param name="valueConverter">Value converter instance</param>
            <param name="sourceMemberName">Source member name to supply to the value converter</param>
        </member>
        <member name="T:AutoMapper.IMemberConfigurationExpression">
            <summary>
            Configuration options for an individual member
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.MapFrom(System.Type)">
            <summary>
            Map destination member using a custom value resolver. Used when the value resolver is not known at compile-time
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="valueResolverType">Value resolver type</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.MapFrom(System.Type,System.String)">
            <summary>
            Map destination member using a custom value resolver. Used when the value resolver is not known at compile-time
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="valueResolverType">Value resolver type</param>
            <param name="sourceMemberName">Member to supply to value resolver</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.MapFrom``4(AutoMapper.IMemberValueResolver{``0,``1,``2,``3},System.String)">
            <summary>
            Map destination member using a custom value resolver instance
            </summary>
            <remarks>Not used for LINQ projection (ProjectTo)</remarks>
            <param name="valueResolver">Value resolver instance to use</param>
            <param name="sourceMemberName">Source member to supply to value resolver</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.ConvertUsing(System.Type)">
            <summary>
            Specify a value converter type to convert from the matching source member to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <param name="valueConverterType">Value converter type</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.ConvertUsing(System.Type,System.String)">
            <summary>
            Specify a value converter type to convert from the specified source member name to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <param name="valueConverterType">Value converter type</param>
            <param name="sourceMemberName">Source member name to supply to the value converter</param>
        </member>
        <member name="M:AutoMapper.IMemberConfigurationExpression.ConvertUsing``2(AutoMapper.IValueConverter{``0,``1},System.String)">
            <summary>
            Specify a value converter instance to convert from the specified source member name to the destination member
            </summary>
            <remarks>
            Value converters are similar to type converters, but scoped to a single member. Value resolvers receive the enclosed source/destination objects as parameters.
            Value converters do not. This makes it possible to reuse value converters across multiple members and multiple maps.
            </remarks>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <typeparam name="TDestinationMember">Destination member type</typeparam>
            <param name="valueConverter">Value converter instance</param>
            <param name="sourceMemberName">Source member name to supply to the value converter</param>
        </member>
        <member name="T:AutoMapper.IProjectionMemberConfiguration`3">
            <summary>
            Member configuration options
            </summary>
            <typeparam name="TSource">Source type for this member</typeparam>
            <typeparam name="TMember">Type for this member</typeparam>
            <typeparam name="TDestination">Destination type for this map</typeparam>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.NullSubstitute(System.Object)">
            <summary>
            Substitute a custom value when the source member resolves as null
            </summary>
            <param name="nullSubstitute">Value to use</param>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.MapFrom``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Map destination member using a custom expression. Used in LINQ projection (ProjectTo).
            </summary>
            <typeparam name="TSourceMember">Member type of the source member to use</typeparam>
            <param name="mapExpression">Map expression</param>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.Ignore">
            <summary>
            Ignore this member for configuration validation and skip during mapping
            </summary>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.AllowNull">
            <summary>
            Allow this member to be null. Overrides AllowNullDestinationValues/AllowNullCollection.
            </summary>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.DoNotAllowNull">
            <summary>
            Don't allow this member to be null. Overrides AllowNullDestinationValues/AllowNullCollection.
            </summary>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.ExplicitExpansion(System.Boolean)">
            <summary>
            Ignore this member for LINQ projections unless explicitly expanded during projection
            </summary>
            <param name="value">Is explicitExpansion active</param>
        </member>
        <member name="M:AutoMapper.IProjectionMemberConfiguration`3.AddTransform(System.Linq.Expressions.Expression{System.Func{`2,`2}})">
            <summary>
            Apply a transformation function after any resolved destination member value with the given type
            </summary>
            <param name="transformer">Transformation expression</param>
        </member>
        <member name="T:AutoMapper.IValueConverter`2">
            <summary>
            Converts a source member value to a destination member value
            </summary>
            <typeparam name="TSourceMember">Source member type</typeparam>
            <typeparam name="TDestinationMember">Destination member type</typeparam>
        </member>
        <member name="M:AutoMapper.IValueConverter`2.Convert(`0,AutoMapper.ResolutionContext)">
            <summary>
            Perform conversion from source member value to destination member value
            </summary>
            <param name="sourceMember">Source member object</param>
            <param name="context">Resolution context</param>
            <returns>Destination member value</returns>
        </member>
        <member name="T:AutoMapper.IValueResolver`3">
            <summary>
            Extension point to provide custom resolution for a destination value
            </summary>
        </member>
        <member name="M:AutoMapper.IValueResolver`3.Resolve(`0,`1,`2,AutoMapper.ResolutionContext)">
            <summary>
            Implementors use source object to provide a destination object.
            </summary>
            <param name="source">Source object</param>
            <param name="destination">Destination object, if exists</param>
            <param name="destMember">Destination member</param>
            <param name="context">The context of the mapping</param>
            <returns>Result, typically build from the source resolution result</returns>
        </member>
        <member name="T:AutoMapper.IMemberValueResolver`4">
            <summary>
            Extension point to provide custom resolution for a destination value
            </summary>
        </member>
        <member name="M:AutoMapper.IMemberValueResolver`4.Resolve(`0,`1,`2,`3,AutoMapper.ResolutionContext)">
            <summary>
            Implementors use source object to provide a destination object.
            </summary>
            <param name="source">Source object</param>
            <param name="destination">Destination object, if exists</param>
            <param name="sourceMember">Source member</param>
            <param name="destMember">Destination member</param>
            <param name="context">The context of the mapping</param>
            <returns>Result, typically build from the source resolution result</returns>
        </member>
        <member name="T:AutoMapper.INamingConvention">
            <summary>
            Defines a naming convention strategy
            </summary>
        </member>
        <member name="T:AutoMapper.IProfileExpression">
            <summary>
            Configuration for profile-specific maps
            </summary>
        </member>
        <member name="M:AutoMapper.IProfileExpression.DisableConstructorMapping">
            <summary>
            Disable constructor mapping. Use this if you don't intend to have AutoMapper try to map to constructors
            </summary>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateMap``2">
            <summary>
            Creates a mapping configuration from the <typeparamref name="TSource"/> type to the <typeparamref name="TDestination"/> type
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateMap``2(AutoMapper.MemberList)">
            <summary>
            Creates a mapping configuration from the <typeparamref name="TSource"/> type to the <typeparamref name="TDestination"/> type.
            Specify the member list to validate against during configuration validation.
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="memberList">Member list to validate</param>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateProjection``2">
            <summary>
            Creates a projection configuration from the <typeparamref name="TSource"/> type to the <typeparamref name="TDestination"/> type
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateProjection``2(AutoMapper.MemberList)">
            <summary>
            Creates a projection configuration from the <typeparamref name="TSource"/> type to the <typeparamref name="TDestination"/> type.
            Specify the member list to validate against during configuration validation.
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="memberList">Member list to validate</param>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateMap(System.Type,System.Type)">
            <summary>
            Create a mapping configuration from the source type to the destination type.
            Use this method when the source and destination type are known at runtime and not compile time.
            </summary>
            <param name="sourceType">Source type</param>
            <param name="destinationType">Destination type</param>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.CreateMap(System.Type,System.Type,AutoMapper.MemberList)">
            <summary>
            Creates a mapping configuration from the source type to the destination type.
            Specify the member list to validate against during configuration validation.
            </summary>
            <param name="sourceType">Source type</param>
            <param name="destinationType">Destination type</param>
            <param name="memberList">Member list to validate</param>
            <returns>Mapping expression for more configuration options</returns>
        </member>
        <member name="M:AutoMapper.IProfileExpression.ClearPrefixes">
            <summary>
            Clear the list of recognized prefixes.
            </summary>
        </member>
        <member name="M:AutoMapper.IProfileExpression.RecognizePrefixes(System.String[])">
            <summary>
            Recognize a list of prefixes to be removed from source member names when matching
            </summary>
            <param name="prefixes">List of prefixes</param>
        </member>
        <member name="M:AutoMapper.IProfileExpression.RecognizePostfixes(System.String[])">
            <summary>
            Recognize a list of postfixes to be removed from source member names when matching
            </summary>
            <param name="postfixes">List of postfixes</param>
        </member>
        <member name="M:AutoMapper.IProfileExpression.ReplaceMemberName(System.String,System.String)">
            <summary>
            Provide a new value for a part of a members name
            </summary>
            <param name="original">Original member value</param>
            <param name="newValue">New member value</param>
        </member>
        <member name="M:AutoMapper.IProfileExpression.RecognizeDestinationPrefixes(System.String[])">
            <summary>
            Recognize a list of prefixes to be removed from destination member names when matching
            </summary>
            <param name="prefixes">List of prefixes</param>
        </member>
        <member name="M:AutoMapper.IProfileExpression.RecognizeDestinationPostfixes(System.String[])">
            <summary>
            Recognize a list of postfixes to be removed from destination member names when matching
            </summary>
            <param name="postfixes">List of postfixes</param>
        </member>
        <member name="M:AutoMapper.IProfileExpression.AddGlobalIgnore(System.String)">
            <summary>
            Add a property name to globally ignore. Matches against the beginning of the property names.
            </summary>
            <param name="propertyNameStartingWith">Property name to match against</param>
        </member>
        <member name="P:AutoMapper.IProfileExpression.AllowNullDestinationValues">
            <summary>
            Allow null destination values. If false, destination objects will be created for deep object graphs. Default true.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileExpression.AllowNullCollections">
            <summary>
            Allow null destination collections. If true, null source collections result in null destination collections. Default false.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileExpression.SourceMemberNamingConvention">
            <summary>
            Naming convention for source members
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileExpression.DestinationMemberNamingConvention">
            <summary>
            Naming convention for destination members
            </summary>
        </member>
        <member name="M:AutoMapper.IProfileExpression.IncludeSourceExtensionMethods(System.Type)">
            <summary>
            Include extension methods against source members for matching destination members to. Default source extension methods from <see cref="T:System.Linq.Enumerable"/>
            </summary>
            <param name="type">Static type that contains extension methods</param>
        </member>
        <member name="P:AutoMapper.IProfileExpression.ValueTransformers">
            <summary>
            Value transformers. Modify the list directly or use <see cref="M:AutoMapper.ValueTransformerConfigurationExtensions.Add``1(System.Collections.Generic.List{AutoMapper.ValueTransformerConfiguration},System.Linq.Expressions.Expression{System.Func{``0,``0}})"/>
            </summary>
        </member>
        <member name="T:AutoMapper.MemberList">
            <summary>
            Member list to check for configuration validation
            </summary>
        </member>
        <member name="F:AutoMapper.MemberList.Destination">
            <summary>
            Check that all destination members are mapped
            </summary>
        </member>
        <member name="F:AutoMapper.MemberList.Source">
            <summary>
            Check that all source members are mapped
            </summary>
        </member>
        <member name="F:AutoMapper.MemberList.None">
            <summary>
            Check neither source nor destination members, skipping validation
            </summary>
        </member>
        <member name="M:AutoMapper.IConfigurationProvider.AssertConfigurationIsValid">
            <summary>
            Dry run all configured type maps and throw <see cref="T:AutoMapper.AutoMapperConfigurationException"/> for each problem
            </summary>
        </member>
        <member name="M:AutoMapper.IConfigurationProvider.CreateMapper">
            <summary>
            Create a mapper instance based on this configuration. Mapper instances are lightweight and can be created as needed.
            </summary>
            <returns>The mapper instance</returns>
        </member>
        <member name="M:AutoMapper.IConfigurationProvider.CreateMapper(System.Func{System.Type,System.Object})">
            <summary>
            Create a mapper instance with the specified service constructor to be used for resolvers and type converters.
            </summary>
            <param name="serviceCtor">Service factory to create services</param>
            <returns>The mapper instance</returns>
        </member>
        <member name="M:AutoMapper.IConfigurationProvider.BuildExecutionPlan(System.Type,System.Type)">
            <summary>
            Builds the execution plan used to map the source to destination.
            Useful to understand what exactly is happening during mapping.
            See <a href="https://automapper.readthedocs.io/en/latest/Understanding-your-mapping.html">the wiki</a> for details.
            </summary>
            <param name="sourceType">the runtime type of the source object</param>
            <param name="destinationType">the runtime type of the destination object</param>
            <returns>the execution plan</returns>
        </member>
        <member name="M:AutoMapper.IConfigurationProvider.CompileMappings">
            <summary>
            Compile all underlying mapping expressions to cached delegates.
            Use if you want AutoMapper to compile all mappings up front instead of deferring expression compilation for each first map.
            </summary>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddProfile(AutoMapper.Profile)">
            <summary>
            Add an existing profile
            </summary>
            <param name="profile">Profile to add</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddProfile``1">
            <summary>
            Add an existing profile type. Profile will be instantiated and added to the configuration.
            </summary>
            <typeparam name="TProfile">Profile type</typeparam>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddProfile(System.Type)">
            <summary>
            Add an existing profile type. Profile will be instantiated and added to the configuration.
            </summary>
            <param name="profileType">Profile type</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddProfiles(System.Collections.Generic.IEnumerable{AutoMapper.Profile})">
            <summary>
            Add profiles contained in an IEnumerable
            </summary>
            <param name="enumerableOfProfiles">IEnumerable of Profile</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="assembliesToScan">Assemblies containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.Reflection.Assembly[])">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="assembliesToScan">Assemblies containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="assemblyNamesToScan">Assembly names to load and scan containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.String[])">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="assemblyNamesToScan">Assembly names to load and scan containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="typesFromAssembliesContainingMappingDefinitions">Types from assemblies containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.AddMaps(System.Type[])">
            <summary>
            Add mapping definitions contained in assemblies.
            Looks for <see cref="T:AutoMapper.Profile" /> definitions and classes decorated with <see cref="T:AutoMapper.AutoMapAttribute" />
            </summary>
            <param name="typesFromAssembliesContainingMappingDefinitions">Types from assemblies containing mapping definitions</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.ConstructServicesUsing(System.Func{System.Type,System.Object})">
            <summary>
            Supply a factory method callback for creating resolvers and type converters
            </summary>
            <param name="constructor">Factory method</param>
        </member>
        <member name="M:AutoMapper.IMapperConfigurationExpression.CreateProfile(System.String,System.Action{AutoMapper.IProfileExpression})">
            <summary>
            Create a named profile with the supplied configuration
            </summary>
            <param name="profileName">Profile name, must be unique</param>
            <param name="config">Profile configuration</param>
        </member>
        <member name="P:AutoMapper.IMapperConfigurationExpression.LicenseKey">
            <summary>
            Gets or sets the license key. You can find your license key in your <a href="https://luckypennysoftware.com/account">account</a>.
            </summary>
        </member>
        <member name="M:AutoMapper.MapperConfigurationExpression.AutoMapper#Internal#IGlobalConfigurationExpression#Validator(System.Action{AutoMapper.Configuration.ValidationContext})">
            <summary>
            Add an action to be called when validating the configuration.
            </summary>
            <param name="validator">the validation callback</param>
        </member>
        <member name="P:AutoMapper.MapperConfigurationExpression.AutoMapper#Internal#IGlobalConfigurationExpression#MaxExecutionPlanDepth">
            <summary>
            How many levels deep should AutoMapper try to inline the execution plan for child classes.
            See <a href="https://automapper.readthedocs.io/en/latest/Understanding-your-mapping.html">the docs</a> for details.
            </summary>
        </member>
        <member name="P:AutoMapper.MapperConfigurationExpression.AutoMapper#Internal#IGlobalConfigurationExpression#RecursiveQueriesMaxDepth">
            <summary>
            How many levels deep should recursive queries be expanded.
            Must be zero for EF6. Can be greater than zero for EF Core.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileConfiguration.SourceExtensionMethods">
            <summary>
            Source extension methods included for search
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileConfiguration.ShouldMapProperty">
            <summary>
            Specify which properties should be mapped.
            By default only public properties are mapped.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileConfiguration.ShouldMapField">
            <summary>
            Specify which fields should be mapped.
            By default only public fields are mapped.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileConfiguration.ShouldMapMethod">
            <summary>
            Specify which methods, of those that are eligible (public, parameterless, and non-static or extension methods), should be mapped.
            By default all eligible methods are mapped.
            </summary>
        </member>
        <member name="P:AutoMapper.IProfileConfiguration.ShouldUseConstructor">
            <summary>
            Specify which constructors should be considered for the destination objects.
            By default all constructors are considered.
            </summary>
        </member>
        <member name="T:AutoMapper.Profile">
            <summary>
                Provides a named configuration for maps. Naming conventions become scoped per profile.
            </summary>
        </member>
        <member name="M:AutoMapper.Features.Features`1.Get``1">
            <summary>
            Gets the feature of type <typeparamref name="TFeatureToFind"/>.
            </summary>
            <typeparam name="TFeatureToFind">The type of the feature.</typeparam>
            <returns>The feature or null if feature not exists.</returns>
        </member>
        <member name="M:AutoMapper.Features.Features`1.Set(`0)">
            <summary>
            Add or update the feature. Existing feature of the same type will be replaced.
            </summary>
            <param name="feature">The feature.</param>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfigurationExpression.Features">
            <summary>
            Get the features collection.
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfigurationExpression.Mappers">
            <summary>
            Object mappers
            </summary>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfigurationExpression.Validator(System.Action{AutoMapper.Configuration.ValidationContext})">
            <summary>
            Add an action to be called when validating the configuration.
            </summary>
            <param name="validator">the validation callback</param>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfigurationExpression.MaxExecutionPlanDepth">
            <summary>
            How many levels deep should AutoMapper try to inline the execution plan for child classes.
            See <a href="https://automapper.readthedocs.io/en/latest/Understanding-your-mapping.html">the docs</a> for details.
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfigurationExpression.RecursiveQueriesMaxDepth">
            <summary>
            How many levels deep should recursive queries be expanded.
            Must be zero for EF6. Can be greater than zero for EF Core.
            </summary>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.GetAllTypeMaps">
            <summary>
            Get all configured type maps created
            </summary>
            <returns>All configured type maps</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor(System.Type,System.Type)">
            <summary>
            Find the <see cref="T:AutoMapper.TypeMap"/> for the configured source and destination type
            </summary>
            <param name="sourceType">Configured source type</param>
            <param name="destinationType">Configured destination type</param>
            <returns>Type map configuration</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor(AutoMapper.Internal.TypePair)">
            <summary>
            Find the <see cref="T:AutoMapper.TypeMap"/> for the configured type pair
            </summary>
            <param name="typePair">Type pair</param>
            <returns>Type map configuration</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor``2">
            <summary>
            Find the <see cref="T:AutoMapper.TypeMap"/> for the configured source and destination type
            </summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <returns>Type map configuration</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.ResolveTypeMap(System.Type,System.Type)">
            <summary>
            Resolve the <see cref="T:AutoMapper.TypeMap"/> for the configured source and destination type, checking parent types
            </summary>
            <param name="sourceType">Configured source type</param>
            <param name="destinationType">Configured destination type</param>
            <returns>Type map configuration</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.ResolveTypeMap(AutoMapper.Internal.TypePair)">
            <summary>
            Resolve the <see cref="T:AutoMapper.TypeMap"/> for the configured type pair, checking parent types
            </summary>
            <param name="typePair">Type pair</param>
            <returns>Type map configuration</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid(AutoMapper.TypeMap)">
            <summary>
            Dry run single type map
            </summary>
            <param name="typeMap">Type map to check</param>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid(System.String)">
            <summary>
            Dry run all type maps in given profile
            </summary>
            <param name="profileName">Profile name of type maps to test</param>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid``1">
            <summary>
            Dry run all type maps in given profile
            </summary>
            <typeparam name="TProfile">Profile type</typeparam>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.GetMappers">
            <summary>
            Get all configured mappers
            </summary>
            <returns>List of mappers</returns>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfiguration.Features">
            <summary>
            Gets the features collection.
            </summary>
            <value>The feature collection.</value>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.FindMapper(AutoMapper.Internal.TypePair)">
            <summary>
            Find a matching object mapper.
            </summary>
            <param name="types">the types to match</param>
            <returns>the matching mapper or null</returns>
        </member>
        <member name="M:AutoMapper.Internal.IGlobalConfiguration.BuildExecutionPlan(AutoMapper.Internal.MapRequest@)">
            <summary>
            Builds the execution plan used to map the source to destination.
            Useful to understand what exactly is happening during mapping.
            See <a href="https://automapper.readthedocs.io/en/latest/Understanding-your-mapping.html">the wiki</a> for details.
            </summary>
            <param name="mapRequest">The source/destination map request</param>
            <returns>the execution plan</returns>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfiguration.EnableNullPropagationForQueryMapping">
            <summary>
            Allows to enable null-value propagation for query mapping.
            <remarks>Some providers (such as EntityFrameworkQueryVisitor) do not work with this feature enabled!</remarks>
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IGlobalConfiguration.ServiceCtor">
            <summary>
            Factory method to create formatters, resolvers and type converters
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IProfileExpressionInternal.EnableNullPropagationForQueryMapping">
            <summary>
            Allows to enable null-value propagation for query mapping. 
            <remarks>Some providers (such as EntityFrameworkQueryVisitor) do not work with this feature enabled!</remarks>
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IProfileExpressionInternal.MethodMappingEnabled">
            <summary>
            Disable method mapping. Use this if you don't intend to have AutoMapper try to map from methods.
            </summary>
        </member>
        <member name="P:AutoMapper.Internal.IProfileExpressionInternal.FieldMappingEnabled">
            <summary>
            Disable fields mapping. Use this if you don't intend to have AutoMapper try to map from/to fields.
            </summary>
        </member>
        <member name="M:AutoMapper.Internal.IProfileExpressionInternal.ForAllMaps(System.Action{AutoMapper.TypeMap,AutoMapper.IMappingExpression})">
            <summary>
            Specify common configuration for all type maps.
            </summary>
            <param name="configuration">configuration callback</param>
        </member>
        <member name="M:AutoMapper.Internal.IProfileExpressionInternal.ForAllPropertyMaps(System.Func{AutoMapper.PropertyMap,System.Boolean},System.Action{AutoMapper.PropertyMap,AutoMapper.IMemberConfigurationExpression})">
            <summary>
            Customize configuration for all members across all maps
            </summary>
            <param name="condition">Condition</param>
            <param name="memberOptions">Callback for member options. Use the property map for conditional maps.</param>
        </member>
        <member name="T:AutoMapper.Internal.TypeDetails">
            <summary>
            Contains cached reflection information for easy retrieval
            </summary>
        </member>
        <member name="M:AutoMapper.Internal.TypeDetails.#ctor(System.Type,AutoMapper.ProfileMap)">
            <summary>
            Contains cached reflection information for easy retrieval
            </summary>
        </member>
        <member name="T:AutoMapper.Internal.Mappers.IObjectMapper">
            <summary>
            Mapping execution strategy, as a chain of responsibility
            </summary>
        </member>
        <member name="M:AutoMapper.Internal.Mappers.IObjectMapper.IsMatch(AutoMapper.Internal.TypePair)">
            <summary>
            When true, the mapping engine will use this mapper as the strategy
            </summary>
            <param name="context">Resolution context</param>
            <returns>Is match</returns>
        </member>
        <member name="M:AutoMapper.Internal.Mappers.IObjectMapper.MapExpression(AutoMapper.Internal.IGlobalConfiguration,AutoMapper.ProfileMap,AutoMapper.MemberMap,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Builds a mapping expression equivalent to the base Map method
            </summary>
            <param name="configuration"></param>
            <param name="profileMap"></param>
            <param name="memberMap"></param>
            <param name="sourceExpression">Source parameter</param>
            <param name="destExpression">Destination parameter</param>
            
            <returns>Map expression</returns>
        </member>
        <member name="T:AutoMapper.Internal.Mappers.ObjectMapper`2">
            <summary>
            Base class for simple object mappers that don't want to use expressions.
            </summary>
            <typeparam name="TSource">type of the source</typeparam>
            <typeparam name="TDestination">type of the destination</typeparam>
        </member>
        <member name="M:AutoMapper.Internal.Mappers.ObjectMapper`2.IsMatch(AutoMapper.Internal.TypePair)">
            <summary>
            When true, the mapping engine will use this mapper as the strategy
            </summary>
            <param name="context">Resolution context</param>
            <returns>Is match</returns>
        </member>
        <member name="M:AutoMapper.Internal.Mappers.ObjectMapper`2.Map(`0,`1,System.Type,System.Type,AutoMapper.ResolutionContext)">
            <summary>
            Performs conversion from source to destination type
            </summary>
            <param name="source">Source object</param>
            <param name="destination">Destination object</param>
            <param name="sourceType">The compile time type of the source object</param>
            <param name="destinationType">The compile time type of the destination object</param>
            <param name="context">Resolution context</param>
            <returns>Destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapperBase.Map``1(System.Object)">
            <summary>
            Execute a mapping from the source object to a new destination object.
            The source type is inferred from the source object.
            </summary>
            <typeparam name="TDestination">Destination type to create</typeparam>
            <param name="source">Source object to map from</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapperBase.Map``2(``0)">
            <summary>
            Execute a mapping from the source object to a new destination object.
            </summary>
            <typeparam name="TSource">Source type to use</typeparam>
            <typeparam name="TDestination">Destination type to create</typeparam>
            <param name="source">Source object to map from</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapperBase.Map``2(``0,``1)">
            <summary>
            Execute a mapping from the source object to the existing destination object.
            </summary>
            <typeparam name="TSource">Source type to use</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="source">Source object to map from</param>
            <param name="destination">Destination object to map into</param>
            <returns>The mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapperBase.Map(System.Object,System.Type,System.Type)">
            <summary>
            Execute a mapping from the source object to a new destination object with explicit <see cref="T:System.Type"/> objects
            </summary>
            <param name="source">Source object to map from</param>
            <param name="sourceType">Source type to use</param>
            <param name="destinationType">Destination type to create</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapperBase.Map(System.Object,System.Object,System.Type,System.Type)">
            <summary>
            Execute a mapping from the source object to existing destination object with explicit <see cref="T:System.Type"/> objects
            </summary>
            <param name="source">Source object to map from</param>
            <param name="destination">Destination object to map into</param>
            <param name="sourceType">Source type to use</param>
            <param name="destinationType">Destination type to use</param>
            <returns>The mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapper.Map``1(System.Object,System.Action{AutoMapper.IMappingOperationOptions{System.Object,``0}})">
            <summary>
            Execute a mapping from the source object to a new destination object with supplied mapping options.
            </summary>
            <typeparam name="TDestination">Destination type to create</typeparam>
            <param name="source">Source object to map from</param>
            <param name="opts">Mapping options</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapper.Map``2(``0,System.Action{AutoMapper.IMappingOperationOptions{``0,``1}})">
            <summary>
            Execute a mapping from the source object to a new destination object with supplied mapping options.
            </summary>
            <typeparam name="TSource">Source type to use</typeparam>
            <typeparam name="TDestination">Destination type to create</typeparam>
            <param name="source">Source object to map from</param>
            <param name="opts">Mapping options</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapper.Map``2(``0,``1,System.Action{AutoMapper.IMappingOperationOptions{``0,``1}})">
            <summary>
            Execute a mapping from the source object to the existing destination object with supplied mapping options.
            </summary>
            <typeparam name="TSource">Source type to use</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="source">Source object to map from</param>
            <param name="destination">Destination object to map into</param>
            <param name="opts">Mapping options</param>
            <returns>The mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapper.Map(System.Object,System.Type,System.Type,System.Action{AutoMapper.IMappingOperationOptions{System.Object,System.Object}})">
            <summary>
            Execute a mapping from the source object to a new destination object with explicit <see cref="T:System.Type"/> objects and supplied mapping options.
            </summary>
            <param name="source">Source object to map from</param>
            <param name="sourceType">Source type to use</param>
            <param name="destinationType">Destination type to create</param>
            <param name="opts">Mapping options</param>
            <returns>Mapped destination object</returns>
        </member>
        <member name="M:AutoMapper.IMapper.Map(System.Object,System.Object,System.Type,System.Type,System.Action{AutoMapper.IMappingOperationOptions{System.Object,System.Object}})">
            <summary>
            Execute a mapping from the source object to existing destination object with supplied mapping options and explicit <see cref="T:System.Type"/> objects
            </summary>
            <param name="source">Source object to map from</param>
            <param name="destination">Destination object to map into</param>
            <param name="sourceType">Source type to use</param>
            <param name="destinationType">Destination type to use</param>
            <param name="opts">Mapping options</param>
            <returns>The mapped destination object</returns>
        </member>
        <member name="P:AutoMapper.IMapper.ConfigurationProvider">
            <summary>
            Configuration provider for performing maps
            </summary>
        </member>
        <member name="M:AutoMapper.IMapper.ProjectTo``1(System.Linq.IQueryable,System.Object,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Project the input queryable.
            </summary>
            <remarks>Projections are only calculated once and cached</remarks>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="source">Queryable source</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Queryable result, use queryable extension methods to project and execute result</returns>
        </member>
        <member name="M:AutoMapper.IMapper.ProjectTo``1(System.Linq.IQueryable,System.Collections.Generic.IDictionary{System.String,System.Object},System.String[])">
            <summary>
            Project the input queryable.
            </summary>
            <typeparam name="TDestination">Destination type to map to</typeparam>
            <param name="source">Queryable source</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Queryable result, use queryable extension methods to project and execute result</returns>
        </member>
        <member name="M:AutoMapper.IMapper.ProjectTo(System.Linq.IQueryable,System.Type,System.Collections.Generic.IDictionary{System.String,System.Object},System.String[])">
            <summary>
            Project the input queryable.
            </summary>
            <param name="source">Queryable source</param>
            <param name="destinationType">Destination type to map to</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Queryable result, use queryable extension methods to project and execute result</returns>
        </member>
        <member name="T:AutoMapper.MemberMap">
            <summary>
            The base class for member maps (property, constructor and path maps).
            </summary>
        </member>
        <member name="M:AutoMapper.ValueTransformerConfigurationExtensions.Add``1(System.Collections.Generic.List{AutoMapper.ValueTransformerConfiguration},System.Linq.Expressions.Expression{System.Func{``0,``0}})">
            <summary>
            Apply a transformation function after any resolved destination member value with the given type
            </summary>
            <typeparam name="TValue">Value type to match and transform</typeparam>
            <param name="valueTransformers">Value transformer list</param>
            <param name="transformer">Transformation expression</param>
        </member>
        <member name="T:AutoMapper.QueryableExtensions.Extensions">
            <summary>
            Queryable extensions for AutoMapper
            </summary>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo``1(System.Linq.IQueryable,AutoMapper.IConfigurationProvider,System.Object,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Extension method to project from a queryable using the provided mapping engine
            </summary>
            <remarks>Projections are only calculated once and cached</remarks>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="source">Queryable source</param>
            <param name="configuration">Mapper configuration</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Expression to project into</returns>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo``1(System.Linq.IQueryable,AutoMapper.IConfigurationProvider,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Extension method to project from a queryable using the provided mapping engine
            </summary>
            <remarks>Projections are only calculated once and cached</remarks>
            <typeparam name="TDestination">Destination type</typeparam>
            <param name="source">Queryable source</param>
            <param name="configuration">Mapper configuration</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Expression to project into</returns>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo``1(System.Linq.IQueryable,AutoMapper.IConfigurationProvider,System.Collections.Generic.IDictionary{System.String,System.Object},System.String[])">
            <summary>
            Projects the source type to the destination type given the mapping configuration
            </summary>
            <typeparam name="TDestination">Destination type to map to</typeparam>
            <param name="source">Queryable source</param>
            <param name="configuration">Mapper configuration</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Queryable result, use queryable extension methods to project and execute result</returns>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo(System.Linq.IQueryable,System.Type,AutoMapper.IConfigurationProvider)">
            <summary>
            Extension method to project from a queryable using the provided mapping engine
            </summary>
            <remarks>Projections are only calculated once and cached</remarks>
            <param name="source">Queryable source</param>
            <param name="destinationType">Destination type</param>
            <param name="configuration">Mapper configuration</param>
            <returns>Expression to project into</returns>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo(System.Linq.IQueryable,System.Type,AutoMapper.IConfigurationProvider,System.Collections.Generic.IDictionary{System.String,System.Object},System.String[])">
            <summary>
            Projects the source type to the destination type given the mapping configuration
            </summary>
            <param name="source">Queryable source</param>
            <param name="destinationType">Destination type to map to</param>
            <param name="configuration">Mapper configuration</param>
            <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
            <param name="membersToExpand">Explicit members to expand</param>
            <returns>Queryable result, use queryable extension methods to project and execute result</returns>
        </member>
        <member name="T:AutoMapper.QueryableExtensions.NullsafeQueryRewriter">
            <summary>
            Expression visitor for making member access null-safe.
            </summary>
            <remarks>
            NullSafeQueryRewriter is copied from the NeinLinq project, licensed under the MIT license.
            Copyright (c) 2014-2018 Axel Heer.
            See https://github.com/axelheer/nein-linq/blob/master/src/NeinLinq/NullsafeQueryRewriter.cs
            </remarks>
        </member>
        <member name="M:AutoMapper.QueryableExtensions.NullsafeQueryRewriter.VisitMember(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:AutoMapper.QueryableExtensions.NullsafeQueryRewriter.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="T:AutoMapper.ResolutionContext">
            <summary>
            Context information regarding resolution of a destination value
            </summary>
        </member>
        <member name="P:AutoMapper.ResolutionContext.State">
            <summary>
            The state passed in the options of the Map call.
            Mutually exclusive with <see cref="P:AutoMapper.ResolutionContext.Items"/> per Map call.
            </summary>
        </member>
        <member name="P:AutoMapper.ResolutionContext.Items">
            <summary>
            The items passed in the options of the Map call.
            Mutually exclusive with <see cref="P:AutoMapper.ResolutionContext.State"/> per Map call.
            </summary>
        </member>
        <member name="M:AutoMapper.ResolutionContext.TryGetItems(System.Collections.Generic.Dictionary{System.String,System.Object}@)">
            <summary>
            The items passed in the options of the Map call. Returns false when no context was passed.
            </summary>
        </member>
        <member name="P:AutoMapper.ResolutionContext.Mapper">
            <summary>
            Current mapper
            </summary>
        </member>
        <member name="P:AutoMapper.ResolutionContext.InstanceCache">
            <summary>
            Instance cache for resolving circular references
            </summary>
        </member>
        <member name="P:AutoMapper.ResolutionContext.TypeDepth">
            <summary>
            Instance cache for resolving keeping track of depth
            </summary>
        </member>
        <member name="T:AutoMapper.TypeMap">
            <summary>
            Main configuration object holding all mapping configuration for a source and destination type
            </summary>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions">
            <summary>
            Extensions to scan for AutoMapper classes and register the configuration, mapping, and extensions with the service collection:
            <list type="bullet">
            <item> Finds <see cref="T:AutoMapper.Profile"/> classes and initializes a new <see cref="T:AutoMapper.MapperConfiguration" />,</item> 
            <item> Scans for <see cref="T:AutoMapper.ITypeConverter`2"/>, <see cref="T:AutoMapper.IValueResolver`3"/>, <see cref="T:AutoMapper.IMemberValueResolver`4" /> and <see cref="T:AutoMapper.IMappingAction`2"/> implementations and registers them as <see cref="F:Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient"/>, </item>
            <item> Registers <see cref="T:AutoMapper.IConfigurationProvider"/> as <see cref="F:Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton"/>, and</item>
            <item> Registers <see cref="T:AutoMapper.IMapper"/> as a configurable <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceLifetime"/> (default is <see cref="F:Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient"/>)</item>
            </list>
            After calling AddAutoMapper you can resolve an <see cref="T:AutoMapper.IMapper" /> instance from a scoped service provider, or as a dependency
            To use <see cref="M:AutoMapper.QueryableExtensions.Extensions.ProjectTo``1(System.Linq.IQueryable,AutoMapper.IConfigurationProvider,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])" /> you can resolve the <see cref="T:AutoMapper.IConfigurationProvider"/> instance directly for from an <see cref="T:AutoMapper.IMapper" /> instance.
            </summary>
        </member>
    </members>
</doc>
